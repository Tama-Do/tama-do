// Copyright 2015-present 650 Industries. All rights reserved.
'use strict';

// Set EXPO_VIEW_DIR to universe/exponent to test locally

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prepareDetachedBuildAsync = exports.detachIOSAsync = exports.detachAsync = undefined;

let detachAsync = exports.detachAsync = (() => {
  var _ref = _asyncToGenerator(function* (projectRoot) {
    let user = yield (_User || _load_User()).default.ensureLoggedInAsync();

    if (!user) {
      throw new Error('Internal error -- somehow detach is being run in offline mode.');
    }

    let username = user.username;
    let { exp } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);
    let experienceName = `@${username}/${exp.slug}`;
    let experienceUrl = `exp://exp.host/${experienceName}`;

    // Check to make sure project isn't fully detached already
    let hasIosDirectory = _isDirectory(_path.default.join(projectRoot, 'ios'));
    let hasAndroidDirectory = _isDirectory(_path.default.join(projectRoot, 'android'));

    if (hasIosDirectory && hasAndroidDirectory) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.DIRECTORY_ALREADY_EXISTS, 'Error detaching. `ios` and `android` directories already exist.');
    }

    // Project was already detached on Windows or Linux
    if (!hasIosDirectory && hasAndroidDirectory && process.platform === 'darwin') {
      let response = yield yesnoAsync(`This will add an Xcode project and leave your existing Android project alone. Enter 'yes' to continue:`);
      if (!response) {
        console.log('Exiting...');
        return false;
      }
    }

    if (hasIosDirectory && !hasAndroidDirectory) {
      throw new Error('`ios` directory already exists. Please remove it and try again.');
    }

    console.log('Validating project manifest...');
    const configName = yield (_ProjectUtils || _load_ProjectUtils()).configFilenameAsync(projectRoot);
    if (!exp.name) {
      throw new Error(`${configName} is missing \`name\``);
    }

    if (!exp.android || !exp.android.package) {
      throw new Error(`${configName} is missing android.package field. See https://docs.expo.io/versions/latest/guides/configuration.html#package`);
    }

    if (!exp.sdkVersion) {
      throw new Error(`${configName} is missing \`sdkVersion\``);
    }

    let majorSdkVersion = (0, (_ExponentTools || _load_ExponentTools()).parseSdkMajorVersion)(exp.sdkVersion);
    if (majorSdkVersion < 16) {
      throw new Error(`${configName} must be updated to SDK 16.0.0 or newer to be detached.`);
    }

    const versions = yield (_Versions || _load_Versions()).versionsAsync();
    let sdkVersionConfig = versions.sdkVersions[exp.sdkVersion];
    if (!sdkVersionConfig || !sdkVersionConfig.androidExpoViewUrl || !sdkVersionConfig.iosExpoViewUrl) {
      if (process.env.EXPO_VIEW_DIR) {
        console.warn(`Detaching is not supported for SDK ${exp.sdkVersion}; ignoring this because you provided EXPO_VIEW_DIR`);
        sdkVersionConfig = {};
      } else {
        throw new Error(`Detaching is not supported for SDK version ${exp.sdkVersion}`);
      }
    }

    if (process.platform !== 'darwin') {
      let response = yield yesnoAsync(`Can't create an iOS project since you are not on macOS. You can rerun this command on macOS in the future to add an iOS project. Enter 'yes' to continue and just create an Android project:`);
      if (!response) {
        console.log('Exiting...');
        return false;
      }
    }

    // Modify exp.json
    exp.isDetached = true;

    if (!exp.detach) {
      exp.detach = {};
    }

    if (!exp.detach.scheme) {
      let detachedUUID = (_uuid || _load_uuid()).default.v4().replace(/-/g, '');
      exp.detach.scheme = `exp${detachedUUID}`;
    }

    let expoDirectory = _path.default.join(projectRoot, '.expo-source');
    (_mkdirp || _load_mkdirp()).default.sync(expoDirectory);

    // iOS
    if (process.platform === 'darwin' && !hasIosDirectory) {
      const iosClientVersion = sdkVersionConfig.iosVersion ? sdkVersionConfig.iosVersion : versions.iosVersion;
      yield detachIOSAsync(projectRoot, exp.sdkVersion, experienceUrl, exp, sdkVersionConfig.iosExpoViewUrl, iosClientVersion);
      exp.detach.iosExpoViewUrl = sdkVersionConfig.iosExpoViewUrl;
    }

    // Android
    if (!hasAndroidDirectory) {
      let androidDirectory = _path.default.join(expoDirectory, 'android');
      (_rimraf || _load_rimraf()).default.sync(androidDirectory);
      (_mkdirp || _load_mkdirp()).default.sync(androidDirectory);
      yield detachAndroidAsync(projectRoot, androidDirectory, exp.sdkVersion, experienceUrl, exp, sdkVersionConfig.androidExpoViewUrl);
      exp.detach.androidExpoViewUrl = sdkVersionConfig.androidExpoViewUrl;
    }

    console.log('Writing ExpoKit configuration...');
    // Update exp.json/app.json
    // if we're writing to app.json, we need to place the configuration under the expo key
    const nameToWrite = yield (_ProjectUtils || _load_ProjectUtils()).configFilenameAsync(projectRoot);
    if (nameToWrite === 'app.json') {
      exp = { expo: exp };
    }
    yield _fs.default.promise.writeFile(_path.default.join(projectRoot, nameToWrite), JSON.stringify(exp, null, 2));

    console.log('Finished detaching your project! Look in the `android` and `ios` directories for the respective native projects. Follow the ExpoKit guide at https://docs.expo.io/versions/latest/guides/expokit.html to get your project running.\n');
    return true;
  });

  return function detachAsync(_x) {
    return _ref.apply(this, arguments);
  };
})();

let configureDetachedVersionsPlistAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (configFilePath, detachedSDKVersion, kernelSDKVersion) {
    yield (0, (_ExponentTools || _load_ExponentTools()).modifyIOSPropertyListAsync)(configFilePath, 'EXSDKVersions', function (versionConfig) {
      versionConfig.sdkVersions = [detachedSDKVersion];
      versionConfig.detachedNativeVersions = {
        shell: detachedSDKVersion,
        kernel: kernelSDKVersion
      };
      return versionConfig;
    });
  });

  return function configureDetachedVersionsPlistAsync(_x2, _x3, _x4) {
    return _ref2.apply(this, arguments);
  };
})();

let configureDetachedIOSInfoPlistAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (configFilePath, manifest) {
    let result = yield (0, (_ExponentTools || _load_ExponentTools()).modifyIOSPropertyListAsync)(configFilePath, 'Info', function (config) {
      // add detached scheme
      if (manifest.isDetached && manifest.detach.scheme) {
        if (!config.CFBundleURLTypes) {
          config.CFBundleURLTypes = [{
            CFBundleURLSchemes: []
          }];
        }
        config.CFBundleURLTypes[0].CFBundleURLSchemes.push(manifest.detach.scheme);
      }
      if (config.UIDeviceFamily) {
        delete config.UIDeviceFamily;
      }
      return config;
    });
    return result;
  });

  return function configureDetachedIOSInfoPlistAsync(_x5, _x6) {
    return _ref3.apply(this, arguments);
  };
})();

let cleanPropertyListBackupsAsync = (() => {
  var _ref4 = _asyncToGenerator(function* (configFilePath) {
    yield (0, (_ExponentTools || _load_ExponentTools()).cleanIOSPropertyListBackupAsync)(configFilePath, 'EXShell', false);
    yield (0, (_ExponentTools || _load_ExponentTools()).cleanIOSPropertyListBackupAsync)(configFilePath, 'Info', false);
    yield (0, (_ExponentTools || _load_ExponentTools()).cleanIOSPropertyListBackupAsync)(configFilePath, 'EXSDKVersions', false);
  });

  return function cleanPropertyListBackupsAsync(_x7) {
    return _ref4.apply(this, arguments);
  };
})();

/**
 *  Create a detached Expo iOS app pointing at the given project.
 */


let detachIOSAsync = exports.detachIOSAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (projectRoot, sdkVersion, experienceUrl, manifest, templateProjUrl, iosClientVersion) {
    let { iosProjectDirectory, projectName } = getIosPaths(projectRoot, manifest);

    let expoTemplateDirectory;
    if (process.env.EXPO_VIEW_DIR) {
      // Only for testing
      expoTemplateDirectory = process.env.EXPO_VIEW_DIR;
    } else {
      expoTemplateDirectory = _path.default.join(projectRoot, 'temp-ios-directory');
      (_mkdirp || _load_mkdirp()).default.sync(expoTemplateDirectory);
      console.log('Downloading iOS code...');
      yield (_Api || _load_Api()).default.downloadAsync(templateProjUrl, expoTemplateDirectory, {
        extract: true
      });
    }

    // copy downloaded template xcodeproj into the user's project.
    // HEY: if you need other paths into the extracted archive, be sure and include them
    // when the archive is generated in `ios/pipeline.js`
    console.log('Moving iOS project files...');
    yield (_Utils || _load_Utils()).ncpAsync(_path.default.join(expoTemplateDirectory, 'exponent-view-template', 'ios'), iosProjectDirectory);

    // rename the xcodeproj (and various other things) to the detached project name.
    console.log('Naming iOS project...');
    yield _renameAndMoveIOSFilesAsync(iosProjectDirectory, projectName);

    // use the detached project manifest to configure corresponding native parts
    // of the detached xcodeproj. this is mostly the same configuration used for
    // shell apps.
    console.log('Configuring iOS project...');
    let infoPlistPath = `${iosProjectDirectory}/${projectName}/Supporting`;
    let iconPath = `${iosProjectDirectory}/${projectName}/Assets.xcassets/AppIcon.appiconset`;
    yield (0, (_IosShellApp || _load_IosShellApp()).configureStandaloneIOSInfoPlistAsync)(infoPlistPath, manifest);
    let infoPlist = yield configureDetachedIOSInfoPlistAsync(infoPlistPath, manifest);
    yield (0, (_IosShellApp || _load_IosShellApp()).configureStandaloneIOSShellPlistAsync)(infoPlistPath, manifest, experienceUrl);
    // TODO: logic for when kernel sdk version is different from detached sdk version
    yield configureDetachedVersionsPlistAsync(infoPlistPath, sdkVersion, sdkVersion);
    yield (0, (_ExponentTools || _load_ExponentTools()).configureIOSIconsAsync)(manifest, iconPath, projectRoot);
    // we don't pre-cache JS in this case, TODO: think about whether that's correct

    // render Podfile in new project
    console.log('Configuring iOS dependencies...');

    let podfileSubstitutions = {
      TARGET_NAME: projectName,
      REACT_NATIVE_PATH: _path.default.relative(iosProjectDirectory, _path.default.join(projectRoot, 'node_modules', 'react-native')),
      EXPOKIT_TAG: `ios/${iosClientVersion}`
    };
    if (process.env.EXPOKIT_TAG_IOS) {
      console.log(`EXPOKIT_TAG_IOS: Using custom ExpoKit iOS tag...`);
      podfileSubstitutions.EXPOKIT_TAG = process.env.EXPOKIT_TAG_IOS;
    } else if (process.env.EXPO_VIEW_DIR) {
      console.log('EXPO_VIEW_DIR: Using local ExpoKit source for iOS...');
      podfileSubstitutions.EXPOKIT_PATH = _path.default.relative(iosProjectDirectory, process.env.EXPO_VIEW_DIR);
    }
    yield (0, (_IosPodsTools || _load_IosPodsTools()).renderPodfileAsync)(_path.default.join(expoTemplateDirectory, 'template-files', 'ios', 'ExpoKit-Podfile'), _path.default.join(iosProjectDirectory, 'Podfile'), podfileSubstitutions, sdkVersion);

    console.log('Cleaning up iOS...');
    yield cleanPropertyListBackupsAsync(infoPlistPath);

    if (!process.env.EXPO_VIEW_DIR) {
      rimrafDontThrow(expoTemplateDirectory);
    }

    console.log(`iOS detach is complete!`);
    return;
  });

  return function detachIOSAsync(_x8, _x9, _x10, _x11, _x12, _x13) {
    return _ref5.apply(this, arguments);
  };
})();

let _renameAndMoveIOSFilesAsync = (() => {
  var _ref6 = _asyncToGenerator(function* (projectDirectory, projectName) {
    const filesToTransform = [_path.default.join('exponent-view-template.xcodeproj', 'project.pbxproj'), _path.default.join('exponent-view-template.xcworkspace', 'contents.xcworkspacedata'), _path.default.join('exponent-view-template.xcodeproj', 'xcshareddata', 'xcschemes', 'exponent-view-template.xcscheme')];

    yield Promise.all(filesToTransform.map((() => {
      var _ref7 = _asyncToGenerator(function* (fileName) {
        return (0, (_ExponentTools || _load_ExponentTools()).transformFileContentsAsync)(_path.default.join(projectDirectory, fileName), function (fileString) {
          return fileString.replace(/exponent-view-template/g, projectName);
        });
      });

      return function (_x16) {
        return _ref7.apply(this, arguments);
      };
    })()));

    // order of this array matters
    const filesToMove = ['exponent-view-template', _path.default.join('exponent-view-template.xcodeproj', 'xcshareddata', 'xcschemes', 'exponent-view-template.xcscheme'), 'exponent-view-template.xcodeproj', 'exponent-view-template.xcworkspace'];

    filesToMove.forEach((() => {
      var _ref8 = _asyncToGenerator(function* (fileName) {
        let destFileName = _path.default.join(_path.default.dirname(fileName), `${projectName}${_path.default.extname(fileName)}`);
        yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsync)('/bin/mv', [_path.default.join(projectDirectory, fileName), _path.default.join(projectDirectory, destFileName)]);
      });

      return function (_x17) {
        return _ref8.apply(this, arguments);
      };
    })());

    return;
  });

  return function _renameAndMoveIOSFilesAsync(_x14, _x15) {
    return _ref6.apply(this, arguments);
  };
})();

let regexFileAsync = (() => {
  var _ref9 = _asyncToGenerator(function* (filename, regex, replace) {
    let file = yield _fs.default.promise.readFile(filename);
    let fileString = file.toString();
    yield _fs.default.promise.writeFile(filename, fileString.replace(regex, replace));
  });

  return function regexFileAsync(_x18, _x19, _x20) {
    return _ref9.apply(this, arguments);
  };
})();

let renamePackageAsync = (() => {
  var _ref10 = _asyncToGenerator(function* (directory, originalPkg, destPkg) {
    let originalSplitPackage = originalPkg.split('.');
    let originalDeepDirectory = directory;
    for (let i = 0; i < originalSplitPackage.length; i++) {
      originalDeepDirectory = _path.default.join(originalDeepDirectory, originalSplitPackage[i]);
    }

    // copy files into temp directory
    let tmpDirectory = _path.default.join(directory, 'tmp-exponent-directory');
    (_mkdirp || _load_mkdirp()).default.sync(tmpDirectory);
    yield (_Utils || _load_Utils()).ncpAsync(originalDeepDirectory, tmpDirectory);

    // delete old package
    (_rimraf || _load_rimraf()).default.sync(_path.default.join(directory, originalSplitPackage[0]));

    // make new package
    let newSplitPackage = destPkg.split('.');
    let newDeepDirectory = directory;
    for (let i = 0; i < newSplitPackage.length; i++) {
      newDeepDirectory = _path.default.join(newDeepDirectory, newSplitPackage[i]);
      (_mkdirp || _load_mkdirp()).default.sync(newDeepDirectory);
    }

    // copy from temp to new package
    yield (_Utils || _load_Utils()).ncpAsync(tmpDirectory, newDeepDirectory);

    // delete temp
    (_rimraf || _load_rimraf()).default.sync(tmpDirectory);
  });

  return function renamePackageAsync(_x21, _x22, _x23) {
    return _ref10.apply(this, arguments);
  };
})();

let detachAndroidAsync = (() => {
  var _ref11 = _asyncToGenerator(function* (projectRoot, expoDirectory, sdkVersion, experienceUrl, manifest, expoViewUrl) {
    let tmpExpoDirectory;
    if (process.env.EXPO_VIEW_DIR) {
      // Only for testing
      tmpExpoDirectory = process.env.EXPO_VIEW_DIR;
    } else {
      tmpExpoDirectory = _path.default.join(projectRoot, 'temp-android-directory');
      (_mkdirp || _load_mkdirp()).default.sync(tmpExpoDirectory);
      console.log('Downloading Android code...');
      yield (_Api || _load_Api()).default.downloadAsync(expoViewUrl, tmpExpoDirectory, { extract: true });
    }

    let androidProjectDirectory = _path.default.join(projectRoot, 'android');

    console.log('Moving Android project files...');

    yield (_Utils || _load_Utils()).ncpAsync(_path.default.join(tmpExpoDirectory, 'android', 'maven'), _path.default.join(expoDirectory, 'maven'));
    yield (_Utils || _load_Utils()).ncpAsync(_path.default.join(tmpExpoDirectory, 'android', 'detach-scripts'), _path.default.join(expoDirectory, 'detach-scripts'));
    yield (_Utils || _load_Utils()).ncpAsync(_path.default.join(tmpExpoDirectory, 'exponent-view-template', 'android'), androidProjectDirectory);
    if (process.env.EXPO_VIEW_DIR) {
      (_rimraf || _load_rimraf()).default.sync(_path.default.join(androidProjectDirectory, 'build'));
      (_rimraf || _load_rimraf()).default.sync(_path.default.join(androidProjectDirectory, 'app', 'build'));
    }

    // Fix up app/build.gradle
    console.log('Configuring Android project...');
    let appBuildGradle = _path.default.join(androidProjectDirectory, 'app', 'build.gradle');
    yield regexFileAsync(appBuildGradle, /\/\* UNCOMMENT WHEN DISTRIBUTING/g, '');
    yield regexFileAsync(appBuildGradle, /END UNCOMMENT WHEN DISTRIBUTING \*\//g, '');
    yield regexFileAsync(appBuildGradle, `compile project(':expoview')`, '');

    // Fix AndroidManifest
    let androidManifest = _path.default.join(androidProjectDirectory, 'app', 'src', 'main', 'AndroidManifest.xml');
    yield regexFileAsync(androidManifest, 'PLACEHOLDER_DETACH_SCHEME', manifest.detach.scheme);

    // Fix MainActivity
    let mainActivity = _path.default.join(androidProjectDirectory, 'app', 'src', 'main', 'java', 'detach', 'app', 'template', 'pkg', 'name', 'MainActivity.java');
    yield regexFileAsync(mainActivity, 'TEMPLATE_INITIAL_URL', experienceUrl);

    // Fix package name
    let packageName = manifest.android.package;
    yield renamePackageAsync(_path.default.join(androidProjectDirectory, 'app', 'src', 'main', 'java'), ANDROID_TEMPLATE_PKG, packageName);
    yield renamePackageAsync(_path.default.join(androidProjectDirectory, 'app', 'src', 'test', 'java'), ANDROID_TEMPLATE_PKG, packageName);
    yield renamePackageAsync(_path.default.join(androidProjectDirectory, 'app', 'src', 'androidTest', 'java'), ANDROID_TEMPLATE_PKG, packageName);

    let packageNameMatches = yield (_glob || _load_glob()).default.promise(androidProjectDirectory + '/**/*.@(java|gradle|xml)');
    if (packageNameMatches) {
      let oldPkgRegex = new RegExp(`${ANDROID_TEMPLATE_PKG.replace(/\./g, '\\\.')}`, 'g');
      for (let i = 0; i < packageNameMatches.length; i++) {
        yield regexFileAsync(packageNameMatches[i], oldPkgRegex, packageName);
      }
    }

    // Fix app name
    console.log('Naming Android project...');
    let appName = manifest.name;
    yield regexFileAsync(_path.default.resolve(androidProjectDirectory, 'app', 'src', 'main', 'res', 'values', 'strings.xml'), ANDROID_TEMPLATE_NAME, appName);

    // Fix image
    let icon = manifest.icon;
    if (icon) {
      let iconMatches = yield (_glob || _load_glob()).default.promise(_path.default.join(androidProjectDirectory, 'app', 'src', 'main', 'res') + '/**/ic_launcher.png');
      if (iconMatches) {
        for (let i = 0; i < iconMatches.length; i++) {
          yield _fs.default.promise.unlink(iconMatches[i]);
          // TODO: make more efficient
          yield (0, (_ExponentTools || _load_ExponentTools()).saveIconToPathAsync)(projectRoot, icon, iconMatches[i]);
        }
      }
    }

    // Clean up
    console.log('Cleaning up Android...');
    if (!process.env.EXPO_VIEW_DIR) {
      rimrafDontThrow(tmpExpoDirectory);
    }
    console.log('Android detach is complete!\n');
  });

  return function detachAndroidAsync(_x24, _x25, _x26, _x27, _x28, _x29) {
    return _ref11.apply(this, arguments);
  };
})();

let prepareDetachedBuildAsync = exports.prepareDetachedBuildAsync = (() => {
  var _ref12 = _asyncToGenerator(function* (projectDir, args) {
    let { exp } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectDir);

    if (args.platform === 'ios') {
      let { iosProjectDirectory, projectName } = getIosPaths(projectDir, exp);

      console.log(`Preparing iOS build at ${iosProjectDirectory}...`);
      // These files cause @providesModule naming collisions
      // but are not available until after `pod install` has run.
      let podsDirectory = _path.default.join(iosProjectDirectory, 'Pods');
      if (!_isDirectory(podsDirectory)) {
        throw new Error(`Can't find directory ${podsDirectory}, make sure you've run pod install.`);
      }
      let rnPodDirectory = _path.default.join(podsDirectory, 'React');
      if (_isDirectory(rnPodDirectory)) {
        let rnFilesToDelete = yield (_glob || _load_glob()).default.promise(rnPodDirectory + '/**/*.@(js|json)');
        if (rnFilesToDelete) {
          for (let i = 0; i < rnFilesToDelete.length; i++) {
            yield _fs.default.promise.unlink(rnFilesToDelete[i]);
          }
        }
      }
      // insert expo development url into iOS config
      if (!args.skipXcodeConfig) {
        let devUrl = yield (_UrlUtils || _load_UrlUtils()).constructManifestUrlAsync(projectDir);
        let configFilePath = _path.default.join(iosProjectDirectory, projectName, 'Supporting');

        // EXBuildConstants is included in newer ExpoKit projects,
        // but in the case of older ones, modify the deprecated file instead
        // (there will be a deprecation warning when they run the project).
        const doesBuildConstantsExist = _fs.default.existsSync(_path.default.join(configFilePath, 'EXBuildConstants.plist'));
        const fileToModify = doesBuildConstantsExist ? 'EXBuildConstants' : 'EXShell';
        yield (0, (_ExponentTools || _load_ExponentTools()).modifyIOSPropertyListAsync)(configFilePath, fileToModify, function (constantsConfig) {
          constantsConfig.developmentUrl = devUrl;
          return constantsConfig;
        });
      }
    } else {
      let androidProjectDirectory = _path.default.join(projectDir, 'android');
      let expoBuildConstantsMatches = yield (_glob || _load_glob()).default.promise(androidProjectDirectory + '/**/ExponentBuildConstants.java');
      if (expoBuildConstantsMatches && expoBuildConstantsMatches.length) {
        let expoBuildConstants = expoBuildConstantsMatches[0];
        let devUrl = yield (_UrlUtils || _load_UrlUtils()).constructManifestUrlAsync(projectDir);
        yield regexFileAsync(expoBuildConstants, /DEVELOPMENT_URL \= \"[^\"]*\"\;/, `DEVELOPMENT_URL = "${devUrl}";`);
      }
    }
  });

  return function prepareDetachedBuildAsync(_x30, _x31) {
    return _ref12.apply(this, arguments);
  };
})();

require('instapromise');

var _mkdirp;

function _load_mkdirp() {
  return _mkdirp = _interopRequireDefault(require('mkdirp'));
}

var _fs = _interopRequireDefault(require('fs'));

var _path = _interopRequireDefault(require('path'));

var _rimraf;

function _load_rimraf() {
  return _rimraf = _interopRequireDefault(require('rimraf'));
}

var _glob;

function _load_glob() {
  return _glob = _interopRequireDefault(require('glob'));
}

var _uuid;

function _load_uuid() {
  return _uuid = _interopRequireDefault(require('uuid'));
}

var _yesno;

function _load_yesno() {
  return _yesno = _interopRequireDefault(require('yesno'));
}

var _ExponentTools;

function _load_ExponentTools() {
  return _ExponentTools = require('./ExponentTools');
}

var _IosShellApp;

function _load_IosShellApp() {
  return _IosShellApp = require('./IosShellApp');
}

var _IosPodsTools;

function _load_IosPodsTools() {
  return _IosPodsTools = require('./IosPodsTools.js');
}

var _Api;

function _load_Api() {
  return _Api = _interopRequireDefault(require('../Api'));
}

var _ErrorCode;

function _load_ErrorCode() {
  return _ErrorCode = _interopRequireDefault(require('../ErrorCode'));
}

var _ProjectUtils;

function _load_ProjectUtils() {
  return _ProjectUtils = _interopRequireWildcard(require('../project/ProjectUtils'));
}

var _User;

function _load_User() {
  return _User = _interopRequireDefault(require('../User'));
}

var _XDLError;

function _load_XDLError() {
  return _XDLError = _interopRequireDefault(require('../XDLError'));
}

var _UrlUtils;

function _load_UrlUtils() {
  return _UrlUtils = _interopRequireWildcard(require('../UrlUtils'));
}

var _Utils;

function _load_Utils() {
  return _Utils = _interopRequireWildcard(require('../Utils'));
}

var _Versions;

function _load_Versions() {
  return _Versions = _interopRequireWildcard(require('../Versions'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const ANDROID_TEMPLATE_PKG = 'detach.app.template.pkg.name';
const ANDROID_TEMPLATE_COMPANY = 'detach.app.template.company.domain';
const ANDROID_TEMPLATE_NAME = 'DetachAppTemplate';

function _isDirectory(dir) {
  try {
    if (_fs.default.statSync(dir).isDirectory()) {
      return true;
    }

    return false;
  } catch (e) {
    return false;
  }
}

function yesnoAsync(question) {
  return new Promise(resolve => {
    (_yesno || _load_yesno()).default.ask(question, null, ok => {
      resolve(ok);
    });
  });
}

function getIosPaths(projectRoot, manifest) {
  let iosProjectDirectory = _path.default.join(projectRoot, 'ios');
  let projectName;
  if (manifest && manifest.name) {
    let projectNameLabel = manifest.name;
    projectName = projectNameLabel.replace(/[^a-z0-9_\-]/gi, '-').toLowerCase();
  } else {
    throw new Error('Cannot configure an ExpoKit app with no name. Are you missing `exp.json`?');
  }
  return {
    iosProjectDirectory,
    projectName
  };
}

function rimrafDontThrow(directory) {
  try {
    (_rimraf || _load_rimraf()).default.sync(directory);
  } catch (e) {
    console.warn(`There was an issue cleaning up, but your project should still work. You may need to manually remove ${directory}. (${e})`);
  }
}
//# sourceMappingURL=../__sourcemaps__/detach/Detach.js.map
