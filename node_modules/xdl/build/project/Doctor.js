'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getExpoSdkStatus = exports.EXPO_SDK_NOT_IMPORTED = exports.EXPO_SDK_NOT_INSTALLED = exports.EXPO_SDK_INSTALLED_AND_IMPORTED = exports.validateWithNetworkAsync = exports.validateLowLatencyAsync = exports.validateWithSchemaFileAsync = exports.FATAL = exports.WARNING = exports.NO_ISSUES = undefined;

let _checkWatchmanVersionAsync = (() => {
  var _ref = _asyncToGenerator(function* (projectRoot) {
    // There's no point in checking any of this stuff if watchman isn't supported on this platform
    if (!(_Watchman || _load_Watchman()).isPlatformSupported()) {
      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-watchman-version');
      return;
    }

    let watchmanVersion = yield (_Watchman || _load_Watchman()).unblockAndGetVersionAsync(projectRoot);

    // If we can't get the watchman version, `getVersionAsync` will return `null`
    if (!watchmanVersion) {
      // watchman is probably just not installed
      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-watchman-version');
      return;
    }

    if ((_semver || _load_semver()).default.lt(watchmanVersion, MIN_WATCHMAN_VERSION)) {
      let warningMessage = `Warning: You are using an old version of watchman (v${watchmanVersion}). This may cause problems for you.\n\nWe recommend that you either uninstall watchman (and XDE will try to use a copy it is bundled with) or upgrade watchman to a newer version, at least v${MIN_WATCHMAN_VERSION}.`;

      // Add a note about homebrew if the user is on a Mac
      if (process.platform === 'darwin') {
        warningMessage += `\n\nIf you are using homebrew, try:\nbrew uninstall watchman; brew install watchman`;
      }
      (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', warningMessage, 'doctor-watchman-version');
    } else {
      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-watchman-version');
    }
  });

  return function _checkWatchmanVersionAsync(_x) {
    return _ref.apply(this, arguments);
  };
})();

let validateWithSchemaFileAsync = exports.validateWithSchemaFileAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (projectRoot, schemaPath) {
    let { exp, pkg } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);
    let schema = JSON.parse((yield _fs.default.readFile.promise(schemaPath, 'utf8')));
    return validateWithSchema(exp, schema.schema, 'exp.json', 'UNVERSIONED');
  });

  return function validateWithSchemaFileAsync(_x2, _x3) {
    return _ref2.apply(this, arguments);
  };
})();

let _validateAssetFieldsAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (projectRoot, exp) {
    try {
      const assetSchemas = yield (_ExpSchema || _load_ExpSchema()).getAssetSchemasAsync(exp.sdkVersion);
      yield Promise.all(assetSchemas.map((() => {
        var _ref4 = _asyncToGenerator(function* ({
          fieldPath,
          schema: { meta: { asset, contentTypePattern, contentTypeHuman } }
        }) {
          const value = (_lodash || _load_lodash()).default.get(exp, fieldPath);
          if (asset && value) {
            if (contentTypePattern) {
              // NOTE(nikki): The '4100' below should be enough for most file types, though we
              //              could probably go shorter....
              //              http://www.garykessler.net/library/file_sigs.html
              const filePath = _path.default.resolve(projectRoot, value);
              const contentType = _fs.default.existsSync(filePath) ? (0, (_fileType || _load_fileType()).default)((yield (0, (_readChunk || _load_readChunk()).default)(filePath, 0, 4100))).mime : (yield (_request || _load_request()).default.promise.head({ url: value })).headers['content-type'];
              if (!contentType.match(new RegExp(contentTypePattern))) {
                const configName = yield (_ProjectUtils || _load_ProjectUtils()).configFilenameAsync(projectRoot);
                (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: Problem in ${configName}. Field '${fieldPath}' should point to a ${contentTypeHuman}, but the file at '${value}' has type '${contentType}'. See ${(_Config || _load_Config()).default.helpUrl}`, `doctor-validate-asset-fields-${fieldPath}`);
              } else {
                (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, `doctor-validate-asset-fields-${fieldPath}`);
              }
            }
          }
        });

        return function (_x6) {
          return _ref4.apply(this, arguments);
        };
      })()));

      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-validate-asset-fields');
    } catch (e) {
      (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expon', `Warning: Problem validating asset fields: ${e.message}.`, 'doctor-validate-asset-fields');
    }
  });

  return function _validateAssetFieldsAsync(_x4, _x5) {
    return _ref3.apply(this, arguments);
  };
})();

let _validatePackageJsonAndExpJsonAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (exp, pkg, projectRoot) {
    if (!exp || !pkg) {
      // readConfigJsonAsync already logged an error
      return FATAL;
    }

    try {
      yield _checkWatchmanVersionAsync(projectRoot);
    } catch (e) {
      (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: Problem checking watchman version. ${e.message}.`, 'doctor-problem-checking-watchman-version');
    }
    (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-problem-checking-watchman-version');

    const expJsonExists = yield (_ProjectUtils || _load_ProjectUtils()).fileExistsAsync(_path.default.join(projectRoot, 'exp.json'));
    const appJsonExists = yield (_ProjectUtils || _load_ProjectUtils()).fileExistsAsync(_path.default.join(projectRoot, 'app.json'));

    if (expJsonExists && appJsonExists) {
      (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: Both app.json and exp.json exist in this directory. Only one should exist for a single project.`, 'doctor-both-app-and-exp-json');
      return WARNING;
    }
    (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-both-app-and-exp-json');

    let sdkVersion = exp.sdkVersion;
    const configName = yield (_ProjectUtils || _load_ProjectUtils()).configFilenameAsync(projectRoot);
    try {
      // TODO(perry) figure out a way to tell the schema validator whether this is exp.json or app.json
      let schema = yield (_ExpSchema || _load_ExpSchema()).getSchemaAsync(sdkVersion);
      let { errorMessage } = validateWithSchema(exp, schema, configName, sdkVersion);

      if (errorMessage) {
        (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', errorMessage, 'doctor-schema-validation');
        return WARNING;
      } else {
        (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-schema-validation');
      }

      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-schema-validation-exception');
    } catch (e) {
      (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: Problem validating ${configName}: ${e.message}.`, 'doctor-schema-validation-exception');
    }

    // Warn if sdkVersion is UNVERSIONED
    if (sdkVersion === 'UNVERSIONED') {
      (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: Using unversioned Expo SDK. Do not publish until you set sdkVersion in ${configName}`, 'doctor-unversioned');
      return WARNING;
    }
    (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-unversioned');

    // react-native is required
    if (!pkg.dependencies || !pkg.dependencies['react-native']) {
      (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: Can't find react-native in package.json dependencies`, 'doctor-no-react-native-in-package-json');
      return WARNING;
    }
    (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-no-react-native-in-package-json');

    // TODO(adam) set up caching for this
    let sdkVersions = yield (_Api || _load_Api()).default.sdkVersionsAsync();
    if (!sdkVersions) {
      (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: Couldn't connect to SDK versions server`, 'doctor-versions-endpoint-failed');
      return WARNING;
    }
    (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-versions-endpoint-failed');

    if (!sdkVersions[sdkVersion]) {
      (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: Invalid sdkVersion. Valid options are ${(_lodash || _load_lodash()).default.keys(sdkVersions).join(', ')}`, 'doctor-invalid-sdk-version');
      return WARNING;
    }
    (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-invalid-sdk-version');

    if ((_Config || _load_Config()).default.validation.reactNativeVersionWarnings) {
      let reactNative = pkg.dependencies['react-native'];

      // Expo fork of react-native is required
      // TODO(2016-12-20): Remove the check for our old "exponentjs" org eventually
      if (!reactNative.match(/(exponent(?:js)?|expo)\/react-native/)) {
        (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: Not using the Expo fork of react-native. See ${(_Config || _load_Config()).default.helpUrl}.`, 'doctor-not-using-expo-fork');
        return WARNING;
      }
      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-not-using-expo-fork');

      try {
        let reactNativeTag = reactNative.match(/sdk-\d+\.\d+\.\d+/)[0];
        let sdkVersionObject = sdkVersions[sdkVersion];

        // TODO: Want to be smarter about this. Maybe warn if there's a newer version.
        if ((_semver || _load_semver()).default.major((_Versions || _load_Versions()).parseSdkVersionFromTag(reactNativeTag)) !== (_semver || _load_semver()).default.major((_Versions || _load_Versions()).parseSdkVersionFromTag(sdkVersionObject['expoReactNativeTag']))) {
          (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: Invalid version of react-native for sdkVersion ${sdkVersion}. Use github:exponent/react-native#${sdkVersionObject['expoReactNativeTag']}`, 'doctor-invalid-version-of-react-native');
          return WARNING;
        }
        (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-invalid-version-of-react-native');

        (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-malformed-version-of-react-native');
      } catch (e) {
        (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: ${reactNative} is not a valid version. Version must be in the form of sdk-x.y.z. Please update your package.json file.`, 'doctor-malformed-version-of-react-native');
        return WARNING;
      }
    }

    // TODO: Check any native module versions here

    return NO_ISSUES;
  });

  return function _validatePackageJsonAndExpJsonAsync(_x7, _x8, _x9) {
    return _ref5.apply(this, arguments);
  };
})();

// TODO: use `yarn check`


let _validateNodeModulesAsync = (() => {
  var _ref6 = _asyncToGenerator(function* (projectRoot) {
    let { exp, pkg } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);
    let nodeModulesPath = projectRoot;
    if (exp.nodeModulesPath) {
      nodeModulesPath = _path.default.join(projectRoot, exp.nodeModulesPath);
    }

    // Check to make sure node_modules exists at all
    try {
      let result = _fs.default.statSync(_path.default.join(nodeModulesPath, 'node_modules'));
      if (!result.isDirectory()) {
        (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', `Error: node_modules directory is missing. Please run \`npm install\` in your project directory.`, 'doctor-node-modules-missing');
        return FATAL;
      }

      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-node-modules-missing');
    } catch (e) {
      (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', `Error: node_modules directory is missing. Please run \`npm install\` in your project directory.`, 'doctor-node-modules-missing');
      return FATAL;
    }

    // Check to make sure react native is installed
    try {
      let result = _fs.default.statSync(_path.default.join(nodeModulesPath, 'node_modules', 'react-native', 'local-cli', 'cli.js'));
      if (!result.isFile()) {
        (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', `Error: React native is not installed. Please run \`npm install\` in your project directory.`, 'doctor-react-native-not-installed');
        return FATAL;
      }

      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-react-native-not-installed');
    } catch (e) {
      (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', `Error: React native is not installed. Please run \`npm install\` in your project directory.`, 'doctor-react-native-not-installed');
      return FATAL;
    }

    // Validate all package.json dependencies are installed and up to date
    if (pkg.dependencies) {
      yield (_Binaries || _load_Binaries()).sourceBashLoginScriptsAsync();

      try {
        yield (0, (_spawnAsync || _load_spawnAsync()).default)('npm', ['--version']);
      } catch (e) {
        (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `\`npm\` command not found. If you have npm installed please run \`npm install -g exp && exp path\`.`, 'doctor-npm-not-found');
        return WARNING;
      }
      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-npm-not-found');

      let npmls;
      try {
        let npmlsCommand = yield (0, (_spawnAsync || _load_spawnAsync()).default)('npm', ['ls', '--json', '--depth', '1'], {
          cwd: nodeModulesPath
        });
        npmls = npmlsCommand.stdout;
      } catch (e) {
        npmls = e.stdout; // `npm ls` sometimes returns an error code
      }

      if (!npmls) {
        (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Problem checking node_modules dependencies. Could not run \`npm ls\` in ${projectRoot}.`, 'doctor-could-not-run-npm-ls');
        return WARNING;
      }
      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-could-not-run-npm-ls');

      let npmlsDependencies;
      try {
        npmlsDependencies = JSON.parse(npmls).dependencies;
      } catch (e) {
        (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Problem checking node_modules dependencies: ${e.message}`, 'doctor-problem-checking-node-modules');
        return WARNING;
      }
      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-problem-checking-node-modules');

      if (npmlsDependencies) {
        let errorStrings = [];
        (_lodash || _load_lodash()).default.forEach(pkg.dependencies, function (versionRequired, dependency) {
          let installedDependency = npmlsDependencies[dependency];
          if (dependency === 'react' && versionRequired.match(/alpha/)) {
            // ignore alpha dependencies on react
          } else if (!installedDependency || !installedDependency.version) {
            if (installedDependency && installedDependency.peerMissing) {
              errorStrings.push(`Warning: '${dependency}' peer depencency missing. Run \`npm ls\` in ${nodeModulesPath} to see full warning.`);
            } else {
              errorStrings.push(`Warning: '${dependency}' dependency is not installed.`);
            }
          } else if (dependency !== 'react-native' && !(_semver || _load_semver()).default.satisfies(installedDependency.version, versionRequired) && !versionRequired.includes(installedDependency.from)) {
            // TODO: also check react-native
            // For react native, `from` field looks like "exponent/react-native#sdk-8.0.1" and
            // versionRequired looks like "github:exponent/react-native#sdk-8.0.0"
            errorStrings.push(`Warning: Installed version ${installedDependency.version} of '${dependency}' does not satisfy required version ${versionRequired}`);
          }
        });

        if (errorStrings.length > 0) {
          errorStrings.push(`\nIf there is an issue running your project, please run \`npm install\` in ${nodeModulesPath} and restart.`);
          (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', errorStrings.join('\n'), 'doctor-node-modules-issues');
          return WARNING;
        } else {
          (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-node-modules-issues');
        }
      }
    }

    return NO_ISSUES;
  });

  return function _validateNodeModulesAsync(_x10) {
    return _ref6.apply(this, arguments);
  };
})();

let validateLowLatencyAsync = exports.validateLowLatencyAsync = (() => {
  var _ref7 = _asyncToGenerator(function* (projectRoot) {
    return validateAsync(projectRoot, false);
  });

  return function validateLowLatencyAsync(_x11) {
    return _ref7.apply(this, arguments);
  };
})();

let validateWithNetworkAsync = exports.validateWithNetworkAsync = (() => {
  var _ref8 = _asyncToGenerator(function* (projectRoot) {
    return validateAsync(projectRoot, true);
  });

  return function validateWithNetworkAsync(_x12) {
    return _ref8.apply(this, arguments);
  };
})();

let validateAsync = (() => {
  var _ref9 = _asyncToGenerator(function* (projectRoot, allowNetwork) {
    let { exp, pkg } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);
    let status = yield _validatePackageJsonAndExpJsonAsync(exp, pkg, projectRoot);

    // Don't block this! It has to make network requests so it's slow.
    if (allowNetwork) {
      _validateAssetFieldsAsync(projectRoot, exp);
    }

    // TODO: this broke once we started using yarn because `npm ls` doesn't
    // work on a yarn install. Use `yarn check` in the future.
    if (status !== FATAL && exp && !exp.ignoreNodeModulesValidation) {
      let nodeModulesStatus = yield _validateNodeModulesAsync(projectRoot);
      if (nodeModulesStatus > status) {
        return nodeModulesStatus;
      }
    }

    return status;
  });

  return function validateAsync(_x13, _x14) {
    return _ref9.apply(this, arguments);
  };
})();

let getExpoSdkStatus = exports.getExpoSdkStatus = (() => {
  var _ref10 = _asyncToGenerator(function* (projectRoot) {
    let { pkg } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);

    try {
      let sdkPkg;
      if (pkg.dependencies['exponent']) {
        sdkPkg = 'exponent';
      } else if (pkg.dependencies['expo']) {
        sdkPkg = 'expo';
      } else {
        return EXPO_SDK_NOT_INSTALLED;
      }

      let mainFilePath = _path.default.join(projectRoot, pkg.main);
      let mainFile = yield _fs.default.readFile.promise(mainFilePath, 'utf8');

      // TODO: support separate .ios.js and .android.js files
      if (mainFile.includes(`from '${sdkPkg}'`) || mainFile.includes(`require('${sdkPkg}')`)) {
        return EXPO_SDK_INSTALLED_AND_IMPORTED;
      } else {
        return EXPO_SDK_NOT_IMPORTED;
      }
    } catch (e) {
      return EXPO_SDK_NOT_IMPORTED;
    }
  });

  return function getExpoSdkStatus(_x15) {
    return _ref10.apply(this, arguments);
  };
})();

exports.validateWithSchema = validateWithSchema;

require('instapromise');

var _lodash;

function _load_lodash() {
  return _lodash = _interopRequireDefault(require('lodash'));
}

var _semver;

function _load_semver() {
  return _semver = _interopRequireDefault(require('semver'));
}

var _fs = _interopRequireDefault(require('fs'));

var _jsonschema;

function _load_jsonschema() {
  return _jsonschema = _interopRequireDefault(require('jsonschema'));
}

var _path = _interopRequireDefault(require('path'));

var _request;

function _load_request() {
  return _request = _interopRequireDefault(require('request'));
}

var _spawnAsync;

function _load_spawnAsync() {
  return _spawnAsync = _interopRequireDefault(require('@exponent/spawn-async'));
}

var _readChunk;

function _load_readChunk() {
  return _readChunk = _interopRequireDefault(require('read-chunk'));
}

var _fileType;

function _load_fileType() {
  return _fileType = _interopRequireDefault(require('file-type'));
}

var _ExpSchema;

function _load_ExpSchema() {
  return _ExpSchema = _interopRequireWildcard(require('./ExpSchema'));
}

var _ProjectUtils;

function _load_ProjectUtils() {
  return _ProjectUtils = _interopRequireWildcard(require('./ProjectUtils'));
}

var _Api;

function _load_Api() {
  return _Api = _interopRequireDefault(require('../Api'));
}

var _Binaries;

function _load_Binaries() {
  return _Binaries = _interopRequireWildcard(require('../Binaries'));
}

var _Config;

function _load_Config() {
  return _Config = _interopRequireDefault(require('../Config'));
}

var _Versions;

function _load_Versions() {
  return _Versions = _interopRequireWildcard(require('../Versions'));
}

var _Watchman;

function _load_Watchman() {
  return _Watchman = _interopRequireWildcard(require('../Watchman'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const NO_ISSUES = exports.NO_ISSUES = 0;
const WARNING = exports.WARNING = 1;
const FATAL = exports.FATAL = 2;

const MIN_WATCHMAN_VERSION = '4.6.0';

function validateWithSchema(exp, schema, configName, sdkVersion) {
  let validator = new (_jsonschema || _load_jsonschema()).default.Validator();
  let validationResult = validator.validate(exp, schema);

  let fullMessage;
  if (validationResult.errors && validationResult.errors.length > 0) {
    fullMessage = `Warning: Problem${validationResult.errors.length > 1 ? 's' : ''} in ${configName}. See https://docs.expo.io/versions/v${sdkVersion}/guides/configuration.html.`;
    for (let error of validationResult.errors) {
      // Formate the message nicely
      let message = error.stack.replace(/instance\./g, '').replace(/exists in instance/g, `exists in ${configName}`).replace('instance additionalProperty', 'additional property');
      fullMessage += `\n  - ${message}.`;
    }
  }

  return { errorMessage: fullMessage };
}

const EXPO_SDK_INSTALLED_AND_IMPORTED = exports.EXPO_SDK_INSTALLED_AND_IMPORTED = 0;
const EXPO_SDK_NOT_INSTALLED = exports.EXPO_SDK_NOT_INSTALLED = 1;
const EXPO_SDK_NOT_IMPORTED = exports.EXPO_SDK_NOT_IMPORTED = 2;
//# sourceMappingURL=../__sourcemaps__/project/Doctor.js.map
